<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JAVA设计模式, zs-blog">
    <meta name="description" content="JAVA设计模式1.单例模式定义：只涉及到一个单一的类，该类创建自己的对象，同时只会创建一个对象被使用特点：构造私有化，自己创建自己的对象并且只会创建一个对象，提供一个返回自身对象的接口供外使用使用场景：1.需要生成唯一序列的环境2.需要频">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JAVA设计模式 | zs-blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.1"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">zs-blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">zs-blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JAVA设计模式</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/web/">
                                <span class="chip bg-color">web</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-03-07
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="JAVA设计模式"><a href="#JAVA设计模式" class="headerlink" title="JAVA设计模式"></a><strong>JAVA设计模式</strong></h1><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a><strong>1.单例模式</strong></h2><p><strong>定义</strong>：只涉及到一个单一的类，该类创建自己的对象，同时只会创建一个对象被使用<br><strong>特点</strong>：构造私有化，自己创建自己的对象并且只会创建一个对象，提供一个返回自身对象的接口供外使用<br>使用场景：<br>1.需要生成唯一序列的环境<br>2.需要频繁实例化然后销毁的对象。<br>3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。<br>4.方便资源相互通信的环境<br>举个例子吧: 我们的电脑中使用的任务管理器，就是一个单例模式。 我们不管点多少次运行任务管理器，是不是操作的都是一个任务管理器的窗口。</p>
<p>单例模式又分为饿汉模式和懒汉模式两种类型    </p>
<ul>
<li>饿汉模式<br>特点：类加载时对象就已经被创建  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;;</span><br><span class="line">    private static Singleton singleton=new Singleton();</span><br><span class="line">    public static Singleton getSingleton()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">静态代码块创建方式：    </span><br><span class="line">public class Singleton1 &#123;</span><br><span class="line">    private Singleton1()&#123;&#125;;</span><br><span class="line">    private static Singleton1 singleton;</span><br><span class="line">    static &#123;</span><br><span class="line">        singleton=new Singleton1();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton1 getSingleton()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>懒汉模式<br>特点: 在使用时才会创建对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">方式一： 锁住获取对象的方法 (锁的粒度大)</span><br><span class="line">public class Singleton2 &#123;</span><br><span class="line">    private Singleton2()&#123;&#125;;</span><br><span class="line">    private static Singleton2 singleton;</span><br><span class="line">    public static synchronized Singleton2 getSingleton()&#123;</span><br><span class="line">        if(singleton==null)&#123;</span><br><span class="line">            singleton = new Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">方式二： 双重检查锁  (锁的粒度小，效率更高)</span><br><span class="line">public class Singleton3 &#123;</span><br><span class="line">    private Singleton3()&#123;&#125;;</span><br><span class="line">    private static Singleton3 singleton;</span><br><span class="line">    public static synchronized Singleton3 getSingleton()&#123;</span><br><span class="line">        //如果不为空不需要占锁</span><br><span class="line">        if(singleton==null)&#123;</span><br><span class="line">            synchronized (Singleton3.class)&#123;</span><br><span class="line">                if(singleton==null)&#123;</span><br><span class="line">                    singleton = new Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">方式三： 静态内部类创建</span><br><span class="line">public class Singleton4 &#123;</span><br><span class="line">    private Singleton4()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private static final Singleton4 singleton4=new Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton4 getSingleton()&#123;</span><br><span class="line">        return SingletonHolder.singleton4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">其它还有什么枚举的创建方式等就不一一说了....</span><br></pre></td></tr></table></figure></li>
</ul>
<p>看完单例模式的几种形式后，我们心里有没有疑问？  单例模式是不是坚不可摧的呢，我们有没有可能会破坏单例模式？  好了，那下面就说下单例模式的几种破坏方式。我们就以上例中的静态内部类创建方式为例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">破坏方式一:  序列化破坏</span><br><span class="line">public class Singleton5 implements Serializable &#123;</span><br><span class="line">    private Singleton5()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    private static class  Singleton5Holder&#123;</span><br><span class="line">        private static final Singleton5 s=new Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton5 getSingleton()&#123;</span><br><span class="line">        return Singleton5Holder.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    在测试类中测试</span><br><span class="line">    //----将对象输出到文件中</span><br><span class="line">    Singleton5 singleton = Singleton5.getSingleton();</span><br><span class="line">    ObjectOutputStream outputStream=new ObjectOutputStream(new FileOutputStream(&quot;C:\\designMode\\a.txt&quot;));</span><br><span class="line">    outputStream.writeObject(singleton);</span><br><span class="line">    outputStream.close();</span><br><span class="line">    //  读取文件转为对象</span><br><span class="line">    ObjectInputStream objectInputStream=new ObjectInputStream(new FileInputStream(&quot;C:\\designMode\\a.txt&quot;));</span><br><span class="line">    Singleton5 singleton8 = (Singleton5) objectInputStream.readObject();</span><br><span class="line">    ObjectInputStream objectInputStream1=new ObjectInputStream(new FileInputStream(&quot;C:\\designMode\\a.txt&quot;));</span><br><span class="line">    Singleton5 singleton9 = (Singleton5) objectInputStream1.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    objectInputStream1.close();</span><br><span class="line">    System.out.println(&quot;singleton8:&quot;+singleton8);</span><br><span class="line">    System.out.println(&quot;singleton9:&quot;+singleton9);</span><br><span class="line"></span><br><span class="line">破坏方式二：反射破坏单例模式    </span><br><span class="line">    Class&lt;Singleton5&gt; singleton5Class = Singleton5.class;</span><br><span class="line">    //获取无参构造对象</span><br><span class="line">    Constructor declaredConstructors = singleton5Class.getDeclaredConstructor();</span><br><span class="line">    //取消访问检查</span><br><span class="line">    declaredConstructors.setAccessible(true);</span><br><span class="line">    //创建对象</span><br><span class="line">    Singleton5 singleton10 = (Singleton5) declaredConstructors.newInstance();</span><br><span class="line">    Singleton5 singleton11 = (Singleton5) declaredConstructors.newInstance();</span><br><span class="line">    System.out.println(singleton10);</span><br><span class="line">    System.out.println(singleton11);</span><br><span class="line"></span><br><span class="line">    Class&lt;Singleton6&gt; singleton6Class = Singleton6.class;</span><br><span class="line">    //获取无参构造对象</span><br><span class="line">    Constructor declaredConstructors1 = singleton6Class.getDeclaredConstructor();</span><br><span class="line">    //取消访问检查</span><br><span class="line">    declaredConstructors1.setAccessible(true);</span><br><span class="line">    //创建对象</span><br><span class="line">    Singleton6 singleton12 = (Singleton6) declaredConstructors1.newInstance();</span><br><span class="line">    System.out.println(&quot;singleton12:&quot;+singleton12);</span><br><span class="line">    Singleton6 singleton13 = (Singleton6) declaredConstructors1.newInstance();</span><br><span class="line">    System.out.println(&quot;singleton13:&quot;+singleton13);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>来看看输出结果吧<br>  反序列化破坏<br>  <img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/1646642430%281%29.jpg"> </p>
<p>  反射破坏<br>  <img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/1646643125%281%29.jpg"> </p>
<p>  可以看到两次的实例均不是一个实例，说明都已破坏了单例模式。 那么，我们该怎么解决这种问题呢？<br>  首先，先分析一下反序列化为什么会出现这种结果。<br>  Singleton5 singleton9 = (Singleton5) objectInputStream1.readObject(); 看看readObject()方法的源码。进入后可以看到有这样一段代码(怎么进的不用我多说了吧，自己debug)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : null;</span><br><span class="line">&#125; catch (Exception ex) &#123;</span><br><span class="line">    throw (IOException) new InvalidClassException(</span><br><span class="line">        desc.forClass().getName(),</span><br><span class="line">        &quot;unable to create instance&quot;).initCause(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以看到，每次反序列化的时候，都会创建一个实例，这就解释了为什么反序列化实例不是一个了。 那么怎么解决怎么问题呢，继续往下看源码。会发现这样一段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if (obj != null &amp;&amp;</span><br><span class="line">          handles.lookupException(passHandle) == null &amp;&amp;</span><br><span class="line">          desc.hasReadResolveMethod())</span><br><span class="line">      &#123;</span><br><span class="line">          Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">          if (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">              rep = cloneArray(rep);</span><br><span class="line">          &#125;</span><br><span class="line">          if (rep != obj) &#123;</span><br><span class="line">              // Filter the replacement object</span><br><span class="line">              if (rep != null) &#123;</span><br><span class="line">                  if (rep.getClass().isArray()) &#123;</span><br><span class="line">                      filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      filterCheck(rep.getClass(), -1);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              handles.setObject(passHandle, obj = rep);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>  关键的地方就在hasReadResolveMethod()关键的地方就在hasReadResolveMethod是true, 就会把invokeReadResolve(obj)生成的对象赋值到obj中. 那么此时我们在单例的类中重写ReadResolve方法，使它返回一个实例就行了，反序列换的时候，就会使用这个实例了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">修改后， 不信的话自己去测试哈！！！</span><br><span class="line">  public class Singleton5 implements Serializable &#123;</span><br><span class="line">      private Singleton5()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">      private static class  Singleton5Holder&#123;</span><br><span class="line">          private static final Singleton5 s=new Singleton5();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static Singleton5 getSingleton()&#123;</span><br><span class="line">          return Singleton5Holder.s;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //反序列化破坏单例模式解决方法: 重写readResolve方法</span><br><span class="line">      public Object readResolve()&#123;</span><br><span class="line">          return Singleton5.getSingleton();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  至于反射会破坏单例模式是因为，反射是通过构造方法创建实例，每次都会创建一个心的实例，所以每次的实例都不一样。 那么怎么解决呢？ 看代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  public class Singleton6 implements Serializable &#123;</span><br><span class="line">    private static boolean flag=false;</span><br><span class="line">    private Singleton6()&#123;</span><br><span class="line">        //反射获取对象破坏单例模式解决方法:   构造里面判断对象是否重复</span><br><span class="line">        synchronized (Singleton6.class)&#123;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                throw new RuntimeException(&quot;不能创建多个对象&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            flag=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private static class  Singleton5Holder&#123;</span><br><span class="line">        private static final Singleton6 s=new Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton6 getSingleton()&#123;</span><br><span class="line">        return Singleton5Holder.s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">在构造方法里面判断对象是否多次创建，是的话就抛异常</span><br></pre></td></tr></table></figure>


<h2 id="2-创建者模式"><a href="#2-创建者模式" class="headerlink" title="2.创建者模式"></a><strong>2.创建者模式</strong></h2><p>假设现在有个需求场景：现在有两种咖啡，摩卡咖啡和拿铁咖啡, 还有一家咖啡店，可以订购两种咖啡, 就这种场景，我们会想到怎么设计呢? 我们先来看看最简陋的设计, 设计一个咖啡的抽象类， 拿铁咖啡类和美式咖啡类实现咖啡接口，然后设计一个咖啡店类，写一个获取咖啡的接口。 具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//咖啡类</span><br><span class="line">public abstract class Coffee &#123;                                 </span><br><span class="line">    public abstract void getName();</span><br><span class="line">    public void addMilk()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加奶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addSweet()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加糖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//拿铁咖啡</span><br><span class="line">public class LatteCoffee extends Coffee &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;拿铁咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//摩卡咖啡</span><br><span class="line">public class MochaCoffee extends Coffee &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;摩卡咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//咖啡店</span><br><span class="line">public class CoffeeStore &#123;</span><br><span class="line">    private Coffee coffee;</span><br><span class="line">    //订购咖啡</span><br><span class="line">    public void orderCoffee(String type)&#123;</span><br><span class="line">        if(&quot;latte&quot;.equals(type))&#123;</span><br><span class="line">            coffee=new LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        if(&quot;mocha&quot;.equals(type))&#123;</span><br><span class="line">            coffee=new MochaCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        coffee.getName();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSweet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样每次通过传入不同的type就可以订到不同的咖啡。但是这样做的话，会有以下问题：</p>
<ol>
<li>咖啡店于咖啡的耦合度过高， 试想一下，假设我现在不止一家咖啡店，还有甜品点，饮品点。。。。，一共有10家点，都可以购买咖啡，现在市面上新出了一款咖啡， 那我还需要在每家店的类里面都修改CoffeeStore这个方法吗？  what? 这不是增加重复的工作量吗？ 基于这一点，我们对以上代码进行了一步优化， 简单工厂模式应运而生。来看看简单工厂模式代码吧！<h2 id="2-1-简单工厂模式"><a href="#2-1-简单工厂模式" class="headerlink" title="2.1 简单工厂模式"></a>2.1 简单工厂模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//咖啡类</span><br><span class="line">public abstract class Coffee1 &#123;</span><br><span class="line">    public abstract void getName();</span><br><span class="line">    public void addMilk()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加奶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addSweet()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加糖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//拿铁咖啡</span><br><span class="line">public class LatteCoffee1 extends Coffee1 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;拿铁咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//摩卡咖啡</span><br><span class="line">public class MochaCoffee1 extends Coffee1 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;摩卡咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//咖啡店</span><br><span class="line">public class CoffeeStore1 &#123;</span><br><span class="line">    public void orderCoffee(String type)&#123;</span><br><span class="line">        Coffee coffee = CoffeeFactory.createCoffee(type);</span><br><span class="line">        coffee.getName();</span><br><span class="line">        coffee.addSweet();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//咖啡工厂</span><br><span class="line">public class CoffeeFactory &#123;</span><br><span class="line">    //生产咖啡</span><br><span class="line">    public static Coffee createCoffee(String type)&#123;</span><br><span class="line">        Coffee coffee=null;</span><br><span class="line">        if(&quot;latte&quot;.equals(type))&#123;</span><br><span class="line">            coffee=new LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        if(&quot;mocha&quot;.equals(type))&#123;</span><br><span class="line">            coffee=new MochaCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        return coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，咖啡店与咖啡之间没有了直接的依赖关系， 生产咖啡的任务交给了工厂类， 那么以后不管多少家店，多少款咖啡，都只需要修改工厂类里面的代码了。 这样做是不是不用再重复的在多家店里面修改代码了！！！  但是简单工厂模式虽然比最初的设计方案优化， 仍存在不少的问题，比如：<br>工厂与咖啡的耦合度还是很高， 新出了咖啡的话，工厂里面还是得修改代码，这显然不符合开闭原则啊。 那么我们思考下，怎么设计符合开闭原则呢？ 来看看另外一种模式–工厂方法模式，先看代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//咖啡类</span><br><span class="line">public abstract class Coffee2 &#123;</span><br><span class="line">    public abstract void getName();</span><br><span class="line">    public void addMilk()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加奶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addSweet()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加糖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CoffeeStore2 &#123;</span><br><span class="line">    private CoffeeFactory2 coffeeFactory2;</span><br><span class="line">    public void setCoffeeFactory2(CoffeeFactory2 coffeeFactory2)&#123;</span><br><span class="line">        this.coffeeFactory2=coffeeFactory2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void orderCoffee()&#123;</span><br><span class="line">        Coffee2 coffee = coffeeFactory2.createCoffee();</span><br><span class="line">        coffee.getName();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSweet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class LatteCoffee2 extends Coffee2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;拿铁咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public interface CoffeeFactory2 &#123;</span><br><span class="line">    public abstract Coffee2 createCoffee();</span><br><span class="line">&#125;</span><br><span class="line">public class LatteCoffeeFactory2 implements CoffeeFactory2&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Coffee2 createCoffee() &#123;</span><br><span class="line">        return new LatteCoffee2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MochaCoffeeFactory2 implements CoffeeFactory2&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Coffee2 createCoffee() &#123;</span><br><span class="line">        return new MochaCoffee2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CoffeeStore2 &#123;</span><br><span class="line">    private CoffeeFactory2 coffeeFactory2;</span><br><span class="line">    public void setCoffeeFactory2(CoffeeFactory2 coffeeFactory2)&#123;</span><br><span class="line">        this.coffeeFactory2=coffeeFactory2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void orderCoffee()&#123;</span><br><span class="line">        Coffee2 coffee = coffeeFactory2.createCoffee();</span><br><span class="line">        coffee.getName();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSweet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
不难发现,和简单工厂模式不同的是,工厂方法模式是将工厂定义为接口，每一种咖啡都有一个具体的咖啡工厂类去实现工厂接口，生产一款咖啡。 这样每次出了新款的咖啡， 只需要新家具体咖啡工厂类就可以了。 对扩展开放，对修改关闭，符合了开闭原则。 但是这样做也有对应的确定，想一下，如果每增加一个产品，我都要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 如果产品多了，容易类爆炸。<br>上面所介绍的工厂方法模式中使用的场景是一类产品的生产，如咖啡厂只生产咖啡；视机厂只生产电视机。 但是如果现实生活中，我们需要一个工厂可以生产不同类型的产品，  如电器厂可以生产电视机和冰箱， 甜品厂可以生产咖啡和甜点，显然用工厂方法模式就不适用，此时可以考虑另外一种设计模式：抽象工厂模式.  要了解抽象工厂模式，首先得清楚两个概念: 产品等级接口，产品族。   </li>
</ol>
<p><strong>产品等级结构</strong>：同一类产品的继承结构，  如有一个电视机抽象类，  还有海尔电视机和海信电视机两个子类，我们可以把它们称为一个产品等级结构（电视机等级结构）。  一个汽车抽象类， 有宝马汽车子类和奔驰汽车子类， 我们也可以把他们称为一个产品等级（汽车等级结构）<br><strong>产品族</strong>：由同一个工厂生产的，不同等级结构的一组产品。  如电器厂生产海尔电视机和海尔冰箱。  海尔电视机属于电视机等级机构， 海尔冰箱数据冰箱等级结构。 海尔电视机和海尔冰箱就构成了一个产品族。     </p>
<p>所以：当系统中所提供的工厂要生产的产品有多个产品等级时，可以考虑使用抽象工厂模式。  </p>
<p>抽象工厂模式的主要角色如下：</p>
<ol>
<li><p>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</p>
</li>
<li><p>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</p>
</li>
<li><p>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</p>
</li>
<li><p>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。  </p>
</li>
</ol>
<p>接下来，我们还是以咖啡店为例子，假设咖啡店不仅要生产咖啡还要生产甜点，如提拉米苏、阿拉伯糖丸等，要是按照工厂方法<br>模式，需要定义提拉米苏类、阿拉伯糖丸类、提拉米苏工厂、阿拉伯糖丸工厂、甜点工厂类，很容易发生类<br>爆炸情况。其中拿铁咖啡、摩卡咖啡是一个产品等级，都是咖啡；提拉米苏、阿拉伯糖丸也是一个产品等<br>级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），摩卡咖啡和阿拉伯糖丸是同一产品<br>族（也就是都属于阿拉伯风味）。所以这个案例可以使用抽象工厂模式实现</p>
<h2 id="2-2-抽象工厂模式"><a href="#2-2-抽象工厂模式" class="headerlink" title="2.2 抽象工厂模式"></a><strong>2.2 抽象工厂模式</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//咖啡类</span><br><span class="line">public abstract class Coffee3 &#123;</span><br><span class="line">    public abstract void getName();</span><br><span class="line">    public void addMilk()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加奶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addSweet()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加糖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//拿铁咖啡</span><br><span class="line">public class LatteCoffee3 extends Coffee3 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;拿铁咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//摩卡咖啡</span><br><span class="line">public class MochaCoffee3 extends Coffee3 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;摩卡咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 甜品工厂  生产咖啡和甜点</span><br><span class="line">public interface DessertFactory &#123;</span><br><span class="line">    public Dessert createDessert();</span><br><span class="line">    public Coffee3 createCoffee();</span><br><span class="line">&#125;</span><br><span class="line">//意大利工厂  生产拿铁咖啡 和  提拉米苏</span><br><span class="line">public class ItalyDessertFactory implements DessertFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Dessert createDessert() &#123;</span><br><span class="line">        return new Trimisu();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Coffee3 createCoffee() &#123;</span><br><span class="line">        return new LatteCoffee3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//阿拉伯工厂  生产摩卡咖啡 和  炸糖丸</span><br><span class="line">public class ArabDessertFactory implements DessertFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Dessert createDessert() &#123;</span><br><span class="line">        return new Luqaimat();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Coffee3 createCoffee() &#123;</span><br><span class="line">        return new MochaCoffee3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/1647078629%281%29.jpg"><br>如果后续要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。  </p>
<p>优点：<br>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始&amp;终只使用同一个产品族中的对象。<br>缺点：<br>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。      </p>
<h3 id="2-3-模式扩展"><a href="#2-3-模式扩展" class="headerlink" title="2.3 模式扩展:"></a><strong>2.3 模式扩展</strong>:</h3><p>除以上几种模式，实际开发中，还有人会用到一种模式,通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全<br>类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">模式扩展</span><br><span class="line">//咖啡类</span><br><span class="line">public abstract class Coffee4 &#123;</span><br><span class="line">    public abstract void getName();</span><br><span class="line">    public void addMilk()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加奶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addSweet()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加糖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//拿铁咖啡</span><br><span class="line">public class LatteCoffee4 extends Coffee4 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;拿铁咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//摩卡咖啡</span><br><span class="line">public class MochaCoffee4 extends Coffee4 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;摩卡咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CoffeeFactory4 &#123;</span><br><span class="line">    public static Map&lt;String,Coffee4&gt; coffee4Map=new HashMap&lt;&gt;();</span><br><span class="line">    //加载配置类 装进map里面</span><br><span class="line">    static &#123;</span><br><span class="line">        Properties p=new Properties();</span><br><span class="line">        InputStream in=CoffeeFactory4.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            p.load(in);</span><br><span class="line">            Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">            for (Object key:keys) &#123;</span><br><span class="line">                String className = p.getProperty((String) key);</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">                Coffee4 coffee4 = (Coffee4) clazz.newInstance();</span><br><span class="line">                coffee4Map.put((String) key,coffee4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public Coffee4 getCoffee(String name)&#123;</span><br><span class="line">        return coffee4Map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</span><br></pre></td></tr></table></figure>
<h2 id="2-4-原型模式"><a href="#2-4-原型模式" class="headerlink" title="2.4 原型模式"></a>2.4 <strong>原型模式</strong></h2><p><strong>定义</strong>: 用一个已经创建实例的对象做原型，复制一个行的对象.<br><strong>使用场景</strong>：  </p>
<ul>
<li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。    </li>
<li>性能和安全要求比较高。    </li>
</ul>
<p><strong>结构</strong>:<br>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。<br>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。<br>访问类：使用具体原型类中的 clone() 方法来复制新的对象。<br>原型模式的克隆分为浅克隆和深克隆。<br>浅克隆: 克隆一个新对象，新对象的属性和原型对象完全相同，对于非基本类型属性，仍指向原<br>有属性所指向的对象的内存地址。<br>深克隆: 克隆一个新对象，对象属性中引用的对象也会被克隆，不再指向原有对象地址。<br>案例:<br>用原型模式生成“三好学生”奖状: 同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//奖状类</span><br><span class="line">public class Citation1 implements Cloneable, Serializable &#123;</span><br><span class="line">    private Student student;</span><br><span class="line">    public Student getStu() &#123; return student; &#125;</span><br><span class="line">    public void setStu(Student stu) &#123; this.student = stu; &#125;</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(student.getName() + &quot;同学：在2020学年第一学期中表现优秀，被评为三好学 生。特发此状！&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    //克隆对象</span><br><span class="line">    @Override</span><br><span class="line">    public Citation1 clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Citation1 citation = (Citation1) super.clone();</span><br><span class="line">        return citation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">    //浅克隆</span><br><span class="line">     Citation1 citation2=new Citation1();</span><br><span class="line">        Student student=new Student();</span><br><span class="line">        student.setName(&quot;张三&quot;);</span><br><span class="line">        citation2.setStu(student);</span><br><span class="line">        citation2.show();</span><br><span class="line">        Citation1 citation3 = citation2.clone();</span><br><span class="line">        Student student1 = citation3.getStu();</span><br><span class="line">        citation3.clone();</span><br><span class="line">        citation3.show();</span><br><span class="line">        System.out.println(citation2==citation3);</span><br><span class="line">        System.out.println(student==student1);</span><br><span class="line">        System.out.println(&quot;深克隆==============================================&quot;);</span><br><span class="line">        //深克隆   通过反序列化方式</span><br><span class="line">        Citation1 citation4 = new Citation1();</span><br><span class="line">        Student student2 = new Student();</span><br><span class="line">        student2.setName(&quot;王五&quot;);</span><br><span class="line">        citation4.setStu(student2);</span><br><span class="line">        //创建对象输出流对象</span><br><span class="line">        ObjectOutputStream os=new ObjectOutputStream(new FileOutputStream(&quot;C:\\Users\\Administrator\\Desktop\\b.txt&quot;));</span><br><span class="line">        //将c1对象写出到文件中</span><br><span class="line">        os.writeObject(citation4);</span><br><span class="line">        os.close();</span><br><span class="line">        //创建对象出入流对象</span><br><span class="line">        ObjectInputStream ins=new ObjectInputStream(new FileInputStream(&quot;C:\\Users\\Administrator\\Desktop\\b.txt&quot;));</span><br><span class="line">        Citation1 citation5 = (Citation1) ins.readObject();</span><br><span class="line">        Student student3 = citation5.getStu();</span><br><span class="line">        citation4.show();</span><br><span class="line">        citation5.show();</span><br><span class="line">        System.out.println(citation5==citation4);</span><br><span class="line">        System.out.println(student2==student);</span><br></pre></td></tr></table></figure>
<p>输出结果:<br><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/designMode/1647745476%281%29.jpg"><br>可以看到，浅克隆后，新对象与原型对象内存地址不一样，但是属性对象student与原型对象是一个实例。  深克隆后， 新对象与原型对象内存地址不一样，属性对象student与原型对象也不一样。</p>
<h2 id="2-5-建造者模式"><a href="#2-5-建造者模式" class="headerlink" title="2.5 建造者模式"></a><strong>2.5 建造者模式</strong></h2><p><strong>定义</strong>: 将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。<br><strong>结构</strong>：     </p>
<ul>
<li>抽象建造者类（Builder）：这个接口规定了要实现复杂对象所需要创建的部分。   </li>
<li>具体建造者类（ConcreteBuilder）：实现builder接口，完成复杂对象各个部件的具体创建。在构造过程完成后，提供产品的实例。</li>
<li>产品类（Product）：要创建的复杂对象。</li>
<li>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分。在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。  </li>
</ul>
<p>案例：<br>创建共享单车： 生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">//抽象建造者</span><br><span class="line">public abstract class Builder &#123;</span><br><span class="line">    Bike bike=new Bike();</span><br><span class="line">    //构建车架</span><br><span class="line">    public abstract void buildFrame();</span><br><span class="line">    //构建座位</span><br><span class="line">    public abstract void buildSeat();</span><br><span class="line">    //构建轮胎</span><br><span class="line">    public abstract void buildTyre();</span><br><span class="line">    //组合成单车</span><br><span class="line">    public abstract Bike createBike();</span><br><span class="line">&#125;</span><br><span class="line">//摩拜单车建造类  （具体建造者）</span><br><span class="line">public class MobikeBuilder extends Builder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildFrame() &#123;</span><br><span class="line">        bike.setFrame(&quot;构建摩拜车架&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildSeat() &#123;</span><br><span class="line">        bike.setSeat(&quot;构建摩拜座位&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildTyre() &#123;</span><br><span class="line">        bike.setTyre(&quot;构建摩拜轮胎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Bike createBike() &#123;</span><br><span class="line">        return bike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//ofo单车建造   (具体建造者)</span><br><span class="line">public class OfoBuilder extends Builder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildFrame() &#123;</span><br><span class="line">        bike.setFrame(&quot;构建ofo车架&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildSeat() &#123;</span><br><span class="line">        bike.setSeat(&quot;构建ofo座位&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildTyre() &#123;</span><br><span class="line">        bike.setTyre(&quot;构建ofo轮胎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Bike createBike() &#123;</span><br><span class="line">        return bike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//自行车   (产品类)</span><br><span class="line">@Data  </span><br><span class="line">public class Bike &#123;</span><br><span class="line">    //车架</span><br><span class="line">    private String frame;</span><br><span class="line">    //座位</span><br><span class="line">    private String seat;</span><br><span class="line">    //轮胎</span><br><span class="line">    private String tyre;</span><br><span class="line">&#125;</span><br><span class="line">//指挥者类</span><br><span class="line">public class Director &#123;</span><br><span class="line">    private Builder builder;</span><br><span class="line">    public Director(Builder builder)&#123;</span><br><span class="line">        this.builder=builder;</span><br><span class="line">    &#125;</span><br><span class="line">    //构建各个部件，最后组装成自行车</span><br><span class="line">    public Bike construct()&#123;</span><br><span class="line">        builder.buildFrame();</span><br><span class="line">        builder.buildSeat();</span><br><span class="line">        builder.buildTyre();</span><br><span class="line">        return builder.createBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Builder mobikeBuilder=new MobikeBuilder();</span><br><span class="line">    Director director=new Director(mobikeBuilder);</span><br><span class="line">    Bike mobike = director.construct();</span><br><span class="line">    Builder ofoBuilder=new OfoBuilder();</span><br><span class="line">    Director director1=new Director(ofoBuilder);</span><br><span class="line">    Bike ofoBike = director1.construct();</span><br><span class="line">    System.out.println(mobike.toString());</span><br><span class="line">    System.out.println(ofoBike.toString());</span><br></pre></td></tr></table></figure>
<p>建造者优缺点<br>优点：  </p>
<ul>
<li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。  </li>
<li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。    </li>
</ul>
<p>缺点：  </p>
<ul>
<li>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制  </li>
</ul>
<h2 id="2-6-创建者模式对比"><a href="#2-6-创建者模式对比" class="headerlink" title="2.6 创建者模式对比"></a><strong>2.6 创建者模式对比</strong></h2><p>工厂方法模式VS建造者模式：<br>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。<br>我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。<br>抽象工厂模式VS建造者模式：<br>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p>
<h1 id="3-结构型模式"><a href="#3-结构型模式" class="headerlink" title="3 结构型模式"></a><strong>3 结构型模式</strong></h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。<br>结构型模式分为以下7种：</p>
<ul>
<li>代理模式</li>
<li>适配器模式</li>
<li>装饰者模式</li>
<li>桥接模式</li>
<li>外观模式</li>
<li>组合模式</li>
<li>享元模式  </li>
</ul>
<h2 id="3-1-代理模式"><a href="#3-1-代理模式" class="headerlink" title="3.1 代理模式"></a><strong>3.1 代理模式</strong></h2><p>概述：<br>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。<br>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。    </p>
<p>定义：<br>在访问对象和目标对象之间提供一个代理对象做中介， 访问对象不能直接访问目标对象，而是通过代理对象来控制对目标对象的访问。 </p>
<p>结构：<br>代理（Proxy）模式分为三种角色：  </p>
<ul>
<li>抽象主题（Subject）类：通过接口或者抽象类来声明真实主题和代理对象所需要实现的业务方法  </li>
<li>真实主题（Real Subject）类： 由目标对象实现了抽象主题中的具体业务。    </li>
<li>代理类（Proxy）： 与真实主题类中的接口相同， 通过内部引用了真实主题对象来实现接口。   </li>
</ul>
<p>案例： 火车站卖票<br>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火<br>车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火<br>车站是目标对象，代售点是代理对象。  </p>
<h3 id="3-1-1-静态代理"><a href="#3-1-1-静态代理" class="headerlink" title="3.1.1 静态代理"></a><strong>3.1.1 静态代理</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//抽象主题类   卖票接口</span><br><span class="line">public interface SellTickets &#123;</span><br><span class="line">    //卖票业务</span><br><span class="line">    public void sell();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//真实主题类： 火车站</span><br><span class="line">public class TrainStation implements SellTickets&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sell() &#123;</span><br><span class="line">        System.out.println(&quot;火车站卖票&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//代理类：代售点</span><br><span class="line">public class ProxyPoint implements SellTickets&#123;</span><br><span class="line">    private TrainStation station = new TrainStation();</span><br><span class="line">    @Override</span><br><span class="line">    public void sell() &#123;</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">//静态代理</span><br><span class="line">ProxyPoint proxyPoint=new ProxyPoint();</span><br><span class="line">proxyPoint.sell();</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/designMode/1647750950%281%29.jpg">   </p>
<p>接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p>
<h3 id="3-1-2-JDK动态代理"><a href="#3-1-2-JDK动态代理" class="headerlink" title="3.1.2 JDK动态代理"></a><strong>3.1.2 JDK动态代理</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//抽象主题类   卖票接口</span><br><span class="line">public interface SellTickets1 &#123;</span><br><span class="line">    //卖票业务</span><br><span class="line">    public void sell();</span><br><span class="line">    public String test();</span><br><span class="line">&#125;</span><br><span class="line">//真实主题类： 火车站</span><br><span class="line">public class TrainStation1 implements SellTickets1 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sell() &#123;</span><br><span class="line">        System.out.println(&quot;火车站卖票&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//代理工厂， 用来创建代理对象</span><br><span class="line">public class ProxyFactory &#123;</span><br><span class="line">    private TrainStation1 trainStation1=new TrainStation1();</span><br><span class="line">    public SellTickets1 getProxyObject()&#123;</span><br><span class="line">        /*newProxyInstance()方法参数说明：</span><br><span class="line">        *ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span><br><span class="line">        * Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代 理对象实现相同的接口</span><br><span class="line">        * InvocationHandler h ： 代理对象的调用处理程序</span><br><span class="line">        */</span><br><span class="line">        SellTickets1 sellTickets1=(SellTickets1) Proxy.newProxyInstance(trainStation1.getClass().getClassLoader(),</span><br><span class="line">            trainStation1.getClass().getInterfaces(),</span><br><span class="line">            new InvocationHandler() &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * invoke 参数</span><br><span class="line">                 * Object proxy: 代理对象</span><br><span class="line">                 *  Method method：代理的业务方法对象</span><br><span class="line">                 *  Object[] args： 接口参数</span><br><span class="line">                 */</span><br><span class="line">                @Override</span><br><span class="line">                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                    System.out.println(&quot;method:&quot;+method.getName());</span><br><span class="line">                    //这里面可以写自己业务的任意增强逻辑</span><br><span class="line">                    //执行真实对象的业务方法</span><br><span class="line">                    Object invoke = method.invoke(trainStation1, args);</span><br><span class="line">                    return invoke;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        return sellTickets1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">ProxyFactory proxyFactory=new ProxyFactory();</span><br><span class="line">SellTickets1 proxyObject = proxyFactory.getProxyObject();</span><br><span class="line">proxyObject.sell();</span><br></pre></td></tr></table></figure>
<p>输出:<br><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/designMode/1647752435%281%29.jpg"><br>使用了动态代理，我们思考下面问题：<br>ProxyFactory是代理类吗？<br>ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生<br>成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构(这里我们只摘取和代理相关重点代码)：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//程序运行过程中动态生成的代理类 </span><br><span class="line">public final class $Proxy0 extends Proxy implements SellTickets&#123;     </span><br><span class="line">    private static Method m3; </span><br><span class="line">    public $Proxy0(InvocationHandler invocationHandler) &#123; </span><br><span class="line">        super(invocationHandler); </span><br><span class="line">    &#125;</span><br><span class="line">    static &#123; </span><br><span class="line">        m3 = Class.forName(&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;).getMethod(&quot;s ell&quot;, new Class[0]); </span><br><span class="line">    &#125;</span><br><span class="line">    public final void sell() &#123; </span><br><span class="line">        this.h.invoke(this, m3, null); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">//Java提供的动态代理相关类 </span><br><span class="line">public class Proxy implements java.io.Serializable &#123; </span><br><span class="line">    protected InvocationHandler h; </span><br><span class="line">    protected Proxy(InvocationHandler h) &#123; </span><br><span class="line">        this.h = h; </span><br><span class="line">    &#125; </span><br><span class="line">//代理工厂类 </span><br><span class="line">public class ProxyFactory &#123; </span><br><span class="line">    private TrainStation station = new TrainStation(); </span><br><span class="line">    public SellTickets getProxyObject() &#123; </span><br><span class="line">        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler()&#123;  </span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; </span><br><span class="line">                System.out.println(&quot;代理点收取一些服务费用(JDK动态代 理方式)&quot;); Object result = method.invoke(station, args); return result; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;); </span><br><span class="line">        return sellTickets; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行流程如下：  </p>
<ol>
<li>当代理对象(SellTickets1)访问sell方法时，会通过多态进入到代理类($Proxy0)里面的sell()方法</li>
<li>代理类($Proxy0)里面的sell()方法又调用了InvocationHandler接口子类的invoke方法，（也就是进入到了我们代理工厂里面的invoke方法） <img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/designMode/1647753703%281%29.jpg"></li>
<li>invoke方法通过反射执行了执行了真实对象所属类(TrainStation1)中的sell方法。    </li>
</ol>
<h3 id="3-1-3-CGLIB动态代理"><a href="#3-1-3-CGLIB动态代理" class="headerlink" title="3.1.3 CGLIB动态代理"></a><strong>3.1.3 CGLIB动态代理</strong></h3><p>同样是上面的案例,  如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。这时候，就可以使用CGLIB动态代理。<br>CGLIB是第三方提供的包，所以需要引入jar包的坐标：    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">//真实主题类： 火车站</span><br><span class="line">public class TrainStation2&#123;</span><br><span class="line">    public void sell() &#123;</span><br><span class="line">        System.out.println(&quot;火车站卖票&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//代理工厂  代理类</span><br><span class="line">public class ProxyFactory1 implements MethodInterceptor &#123;</span><br><span class="line">    private TrainStation2 target = new TrainStation2();</span><br><span class="line">    public TrainStation2 getProxyObject() &#123;</span><br><span class="line">        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span><br><span class="line">        Enhancer enhancer =new Enhancer();</span><br><span class="line">        //设置父类的字节码对象</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        // 设置回调函数</span><br><span class="line">         enhancer.setCallback(this);</span><br><span class="line">        // 创建代理对象</span><br><span class="line">        TrainStation2 obj = (TrainStation2) enhancer.create();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* intercept方法参数说明：</span><br><span class="line">     * o:代理对象</span><br><span class="line">     * method ： 真实对象中的方法的Method实例</span><br><span class="line">     * args ： 实际参数</span><br><span class="line">     * methodProxy ：代理对象中的方法的method实例</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;可以添加增加逻辑&quot;);</span><br><span class="line">        TrainStation2 result = (TrainStation2) methodProxy.invokeSuper(o, objects);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">ProxyFactory proxyFactory=new ProxyFactory();</span><br><span class="line">SellTickets1 proxyObject = proxyFactory.getProxyObject();</span><br><span class="line">proxyObject.sell();</span><br></pre></td></tr></table></figure>
<p>三种代理对比:   </p>
<ul>
<li>jdk代理和CGLIB代理<br>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。  </li>
<li>动态代理和静态代理<br>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。<br>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</li>
</ul>
<h2 id="3-2-适配器模式"><a href="#3-2-适配器模式" class="headerlink" title="3.2 适配器模式"></a><strong>3.2 适配器模式</strong></h2><p><strong>定义</strong>：$<br>将一个接口转换为客户希望的另外一个接口，使得原本由于接口不兼容的那些类能够在一起工作<br><strong>结构</strong>:<br>目标(Target)接口：当前客户所能使用（期待）的接口。<br>适配者（Adaptee）类： 被适配的组件接口 （目标接口通过适配器适配后，真正访问的接口）<br>适配器（Adapter）类： 它是一个转换器，通过继承或者引用适配者类，把适配者接口转为目标接口，使得用户按目标接口的格式访问适配者接口<br>案例 读卡器：<br>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。  </p>
<p><strong>3.2.1 类适配器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//SD卡   目标接口  提供给访问用户的接口</span><br><span class="line">public interface SDCard &#123;</span><br><span class="line">    public void readSDCard();</span><br><span class="line">    public void writeSDCard();</span><br><span class="line">&#125;</span><br><span class="line">public class SDCardImpl implements SDCard&#123;</span><br><span class="line">    public void readSDCard()&#123;</span><br><span class="line">        System.out.println(&quot;读取SD卡&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    public void writeSDCard()&#123;</span><br><span class="line">        System.out.println(&quot;写入SD卡&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">//TF卡  适配者类</span><br><span class="line">public interface TFCard &#123;</span><br><span class="line">    //读卡</span><br><span class="line">    public void readTFCard();</span><br><span class="line">    //写卡</span><br><span class="line">    public void writeTFCard();</span><br><span class="line">&#125;</span><br><span class="line">public class TFCardImpl implements TFCard &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void readTFCard() &#123;</span><br><span class="line">        System.out.println(&quot;读取TF卡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeTFCard() &#123;</span><br><span class="line">        System.out.println(&quot;写入TF卡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//适配器类    SD兼容TF卡</span><br><span class="line">public class SDAdapterTF extends TFCardImpl implements SDCard&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void readSDCard() &#123;</span><br><span class="line">        super.readTFCard();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeSDCard() &#123;</span><br><span class="line">        super.writeTFCard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//电脑类  充当访问者角色</span><br><span class="line">public class Computer1 &#123;</span><br><span class="line">    public void readSD(SDCard sdCard)&#123;</span><br><span class="line">        sdCard.readSDCard();</span><br><span class="line">    &#125;</span><br><span class="line">    public void writeSD(SDCard sdCard)&#123;</span><br><span class="line">        sdCard.writeSDCard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试   电脑访问SD卡的接口，适配器适配到TF卡接口</span><br><span class="line">Computer1 computer = new Computer1();</span><br><span class="line">SDAdapterTF sdAdapterTF=new SDAdapterTF();</span><br><span class="line">computer.readSD(sdAdapterTF);</span><br><span class="line">computer.writeSD(sdAdapterTF);</span><br></pre></td></tr></table></figure>
<p><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/1647586463%281%29.jpg"><br>可以看到，电脑访问SD卡接口，最终通过适配器适配，读取到了TF卡。<br>类适配器可以用于客户类有一个接口规范的情况下，但是耦合度较高，用的不多。    </p>
<p><strong>3.2.2 对象适配器</strong><br>类适配器模式的代码，只需要修改适配器类（SDAdapterTF）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//适配器类    SD兼容TF卡</span><br><span class="line">public class SDAdapterTF1 implements SDCard &#123;</span><br><span class="line">    private TFCard tfCard;</span><br><span class="line">    public SDAdapterTF1(TFCard tfCard)&#123;</span><br><span class="line">        this.tfCard=tfCard;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void readSDCard() &#123;</span><br><span class="line">        tfCard.readTFCard();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeSDCard() &#123;</span><br><span class="line">        tfCard.writeTFCard();</span><br><span class="line">    &#125;</span><br><span class="line">    //测试</span><br><span class="line">    SDAdapterTF1 sdAdapterTF1=new SDAdapterTF1(new TFCardImpl());</span><br><span class="line">    sdAdapterTF1.readSDCard();</span><br><span class="line">    sdAdapterTF1.writeSDCard();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/1647587386%281%29.jpg"><br>对象适配器比类适配器耦合度低，灵活度高，因此对象适配器被使用的更多。    </p>
<h2 id="3-3-装饰者模式"><a href="#3-3-装饰者模式" class="headerlink" title="3.3 装饰者模式"></a><strong>3.3 装饰者模式</strong></h2><p><strong>定义</strong>：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。<br>概述：<br>我们先来看一个快餐店的例子。<br>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。<br>假设我们使用继承的方式，定义一个快餐类或接口，定义快餐的子类炒饭和炒粉类，然后定义炒粉类的子类:鸡蛋炒粉类、培根炒粉类,炒饭类的鸡蛋炒饭类、培根炒饭类.这样做的话存在的问题：  </p>
<ul>
<li>扩展性不好：如果要再加一种配料（火腿肠），我们就会发现需要给炒粉类和炒粉类各添加一个火腿炒粉类和火腿炒饭类。如果要新增一个快餐品类（炒河粉）的话，还需要多添加一个快餐类的子类–炒河粉类，然后炒河粉又需要添加火腿，培根，鸡蛋子类。</li>
<li>产生过多的子类：随着快餐品类的增多，会发现类会越来越多，可能会发生类爆炸。    </li>
</ul>
<p>这时候，就可以考虑使用装饰者模式<br><strong>装饰者模式结构</strong>：</p>
<ul>
<li>抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（Concrete Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子</li>
<li>类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附</li>
</ul>
<p><strong>案例</strong>：<br>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">//快餐类    抽象构件角色</span><br><span class="line">public abstract class FastFood &#123;</span><br><span class="line">    private float price;</span><br><span class="line">    private String desc;</span><br><span class="line">    public FastFood(float price,String desc)&#123;</span><br><span class="line">        this.price=price;</span><br><span class="line">        this.desc=desc;</span><br><span class="line">    &#125;</span><br><span class="line">    public  FastFood()&#123;&#125;;</span><br><span class="line">    public float getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPrice(float price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getDesc() &#123;</span><br><span class="line">        return desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDesc(String desc) &#123;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract float cost();</span><br><span class="line">&#125;</span><br><span class="line">//炒面类  具体构件角色</span><br><span class="line">public class FriedNode extends FastFood &#123;</span><br><span class="line">    public FriedNode()&#123;</span><br><span class="line">        super(8,&quot;炒面&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public float cost()&#123;</span><br><span class="line">        return getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//炒饭类  具体构件角色</span><br><span class="line">public class FriedRice extends FastFood &#123;</span><br><span class="line">    public FriedRice()&#123;</span><br><span class="line">        super(10,&quot;炒饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public float cost()&#123;</span><br><span class="line">        return getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package com.zhangs.pattern.structural.decorate;</span><br><span class="line">//配料类   抽象装饰角色</span><br><span class="line">public abstract class Garnish extends FastFood&#123;</span><br><span class="line">    private FastFood fastFood;</span><br><span class="line">    public FastFood getFastFood() &#123;</span><br><span class="line">        return fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFastFood(FastFood fastFood) &#123;</span><br><span class="line">        this.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Garnish(float price, String desc,FastFood fastFood) &#123;</span><br><span class="line">        super(price, desc);</span><br><span class="line">        this.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//培根类   具体装饰（ConcreteDecorator）角色</span><br><span class="line">public class Bacon extends Garnish &#123;</span><br><span class="line">    public Bacon(FastFood fastFood) &#123;</span><br><span class="line">        super(2, &quot;培根&quot;, fastFood);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public float cost()&#123;</span><br><span class="line">        return super.getFastFood().getPrice()+this.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getDesc()&#123;</span><br><span class="line">        return super.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//鸡蛋类   具体装饰（ConcreteDecorator）角色</span><br><span class="line">public class Egg extends Garnish &#123;</span><br><span class="line">    public Egg(FastFood fastFood) &#123;</span><br><span class="line">        super(1+(float) fastFood.getPrice(), &quot;鸡蛋&quot;+fastFood.getDesc(), fastFood);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public float cost()&#123;</span><br><span class="line">        return this.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getDesc()&#123;</span><br><span class="line">        return super.getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">FastFood fastFood=new FriedRice();    //炒饭</span><br><span class="line">fastFood=new Egg(fastFood);   //加鸡蛋</span><br><span class="line">System.out.println(fastFood.getDesc()+&quot;：&quot;+fastFood.cost()+&quot;元&quot;);</span><br><span class="line">Bacon bacon=new Bacon(fastFood);   //加培根</span><br><span class="line">System.out.println(bacon.getDesc()+&quot;：&quot;+bacon.cost()+&quot;元&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/designMode/1648189783%281%29.jpg"><br><strong>好处</strong>：</p>
<ul>
<li>饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</li>
<li>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以<br>动态扩展一个实现类的功能    </li>
</ul>
<p><strong>使用场景</strong>:   </p>
<ul>
<li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。<br>不能采用继承的情况主要有两类：<br>  第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目<br>  呈爆炸性增长；<br>  第二类是因为类定义不能继承（如final类）</li>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。    </li>
</ul>
<p>JDK中使用装饰者的例子:<br>IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123; </span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        //创建BufferedWriter对象 </span><br><span class="line">        //创建FileWriter对象</span><br><span class="line">        FileWriter fw = new FileWriter(&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;);</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(fw);</span><br><span class="line">        //写数据 </span><br><span class="line">        bw.write(&quot;hello Buffered&quot;);</span><br><span class="line">        bw.close(); &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下它们的结构：<br><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/designMode/1648279253%281%29.jpg"></p>
<p>可以看到，BufferedWriter作为抽象装饰角色，继承了Write(抽象构建角色)类，并且包含了FileWriter（具体构件角色）实例，这完全符合装饰者模式特征.<br>小结：<br>BufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数<br>据的效率。<br>看完代理模式和装饰者模式后，会不会发现他们有很多相似的地方，那么我们来看看他们到底有什么区别呢？<br>代理者和装饰者的区别：<br>相同点： </p>
<ul>
<li>都要实现目标类的业务接口</li>
<li>在两个类中都要申明目标对象</li>
<li>都可以在不修改目标类的前提下增强目标方法  </li>
</ul>
<p>不通点：    </p>
<ul>
<li>目的不同 装饰者是为了增强目标对象 静态代理是为了保护和隐藏目标对象</li>
<li>获取目标对象构建的地方不同 装饰者是由外界传递进来，可以通过构造方法传递 静态代理<br>是在代理类内部创建，以此来隐藏目标对象  </li>
</ul>
<h2 id="3-4-桥接模式"><a href="#3-4-桥接模式" class="headerlink" title="3.4 桥接模式"></a><strong>3.4 桥接模式</strong></h2><p>假设现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：<br><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/designMode/1648280357%281%29.jpg"><br>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。这样的话，如果和很多图形和颜色，可能会造成类爆炸，扩展起来特别不方便。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p>
<p><strong>定义:</strong><br>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。<br><strong>结构:</strong>   </p>
<ul>
<li>抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。  </li>
<li>实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。  </li>
<li>具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。</li>
</ul>
<p>案例:<br>假设需要开发一个跨平台视频播放器，可以在不同操作系统平台（Windows、Mac）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI。该播放器包含了操作系统和视频文件两个维度，适合使用桥接模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//avi文件  具体实现化（Concrete Implementor）角色</span><br><span class="line">public class AVIFile implements VideoFile&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void decode(String fileName) &#123;</span><br><span class="line">        System.out.println(&quot;avi视频文件：&quot;+fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//rmvb文件   具体实现化（Concrete Implementor）角色</span><br><span class="line">public class REVBBFile implements VideoFile&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void decode(String fileName) &#123;</span><br><span class="line">        System.out.println(&quot;rmvb视频文件：&quot;+fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//视频文件    实现化（Implementor）角色</span><br><span class="line">public interface VideoFile &#123;</span><br><span class="line">    void decode(String fileName);</span><br><span class="line">&#125;</span><br><span class="line">//操作系统版本    抽象化（Abstraction）角色</span><br><span class="line">public abstract class OperatingSystemVersion &#123;</span><br><span class="line">    protected VideoFile videoFile;</span><br><span class="line">    public OperatingSystemVersion(VideoFile videoFile) &#123;</span><br><span class="line">        this.videoFile = videoFile;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void play(String fileName);</span><br><span class="line">&#125;</span><br><span class="line">//mac系统  扩展抽象化（Refined Abstraction）角色</span><br><span class="line">public class MacSystem extends OperatingSystemVersion &#123;</span><br><span class="line">    public MacSystem(VideoFile videoFile)&#123;</span><br><span class="line">        super(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void play(String fileName) &#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//avi文件  具体实现化（Concrete Implementor）角色</span><br><span class="line">public class AVIFile implements VideoFile&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void decode(String fileName) &#123;</span><br><span class="line">        System.out.println(&quot;avi视频文件：&quot;+fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line"> System.out.println(&quot;桥接模式==================&quot;);</span><br><span class="line">OperatingSystemVersion windows=new WindowsSystem(new AVIFile());</span><br><span class="line">windows.play(&quot;金刚狼&quot;);</span><br><span class="line">OperatingSystemVersion mac=new MacSystem(new AVIFile());</span><br><span class="line">mac.play(&quot;金刚狼&quot;);</span><br></pre></td></tr></table></figure>
<p>好处:   </p>
<ul>
<li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。<br>如： 后续我们需要加一个linux操作心痛， 只需要再加一个linux系统类实现操作系统接口即可，不需要改原来的代码。</li>
<li>实现细节对客户透明 （用户只需要调用play接口就可实现文件的播放，而不需要知道解析视频文件的方法-decode的具体细节）   </li>
</ul>
<p>使用场景:   </p>
<ul>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。    </li>
</ul>
<h2 id="3-5-外观者模式"><a href="#3-5-外观者模式" class="headerlink" title="3.5 外观者模式"></a><strong>3.5 外观者模式</strong></h2><p>概述：<br>有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。<br><strong>定义:</strong><br>又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。<br><strong>结构：</strong>  </p>
<ul>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。<br>案例:<br>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> // 空调类   子系统（Sub System）角色</span><br><span class="line">public class AirCondition &#123;</span><br><span class="line">    public void on() &#123;</span><br><span class="line">        System.out.println(&quot;打开空调。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void off() &#123;</span><br><span class="line">        System.out.println(&quot;关闭空调。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//电灯类   子系统（Sub System）角色</span><br><span class="line">public class Light &#123;</span><br><span class="line">    //开灯</span><br><span class="line">    public void on() &#123;</span><br><span class="line">        System.out.println(&quot;打开电灯。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //关灯</span><br><span class="line">    public void off() &#123;</span><br><span class="line">        System.out.println(&quot;关闭电灯。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> // 电视机类   子系统（Sub System）角色</span><br><span class="line">public class TV &#123;</span><br><span class="line">    public void on() &#123;</span><br><span class="line">        System.out.println(&quot;打开电视机。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void off() &#123;</span><br><span class="line">        System.out.println(&quot;关闭电视机。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 外观类   外观（Facade）角色，用户主要和该类对象进行交互</span><br><span class="line">public class SmartAppliancesFacade &#123;</span><br><span class="line"></span><br><span class="line">    //聚合电灯对象，电视机对象，空调对象</span><br><span class="line">    private Light light;</span><br><span class="line">    private TV tv;</span><br><span class="line">    private AirCondition airCondition;</span><br><span class="line">    public SmartAppliancesFacade() &#123;</span><br><span class="line">        light = new Light();</span><br><span class="line">        tv = new TV();</span><br><span class="line">        airCondition = new AirCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    //通过语言控制</span><br><span class="line">    public void say(String message) &#123;</span><br><span class="line">        if(message.contains(&quot;打开&quot;)) &#123;</span><br><span class="line">            on();</span><br><span class="line">        &#125; else if(message.contains(&quot;关闭&quot;)) &#123;</span><br><span class="line">            off();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;我还听不懂你说的！！！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //一键打开功能</span><br><span class="line">    private void on() &#123;</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">    &#125;</span><br><span class="line">    //一键关闭功能</span><br><span class="line">    private void off() &#123;</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">SmartAppliancesFacade smartAppliancesFacade=new SmartAppliancesFacade();</span><br><span class="line">smartAppliancesFacade.say(&quot;打开&quot;);   //打开全部电器</span><br><span class="line">smartAppliancesFacade.say(&quot;关闭&quot;);    //关闭全部电器</span><br></pre></td></tr></table></figure>
好处：  </li>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不符合开闭原则，修改很麻烦    </li>
</ul>
<p>使用场景:   </p>
<ul>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关<br>系。</li>
<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li>
<li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。        </li>
</ul>
<h1 id="4-行为型模式"><a href="#4-行为型模式" class="headerlink" title="4. 行为型模式"></a><strong>4. 行为型模式</strong></h1><h2 id="4-6-观察者模式"><a href="#4-6-观察者模式" class="headerlink" title="4.6 观察者模式"></a><strong>4.6 观察者模式</strong></h2><p><strong>定义：</strong><br>又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者同时监听一个主题对象，当主题对象更新时，会通知所有的观察者对象。<br><strong>结构：</strong> </p>
<ul>
<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li>
<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li>
<li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。    </li>
</ul>
<p>案例：<br>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号<br>是被观察者，有多个的微信用户关注了程序猿这个公众号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//抽象观察者类</span><br><span class="line">public interface Observer&#123;</span><br><span class="line">    void update(String message);</span><br><span class="line">&#125;</span><br><span class="line">//微信用户   具体观察者</span><br><span class="line">public class WeChatUser implements Observer&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public WeChatUser(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void update(String message) &#123;</span><br><span class="line">        System.out.println(name+&quot;收到消息:&quot;+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象主题类</span><br><span class="line">public interface Subject &#123;</span><br><span class="line">    //添加观察者</span><br><span class="line">    public void attach(Observer observer);</span><br><span class="line">    //删除观察者</span><br><span class="line">    public void detach(Observer observer);</span><br><span class="line">    //通知订阅消息</span><br><span class="line">    public void notify(String message);</span><br><span class="line">&#125;</span><br><span class="line">//微信公众号  具体主题类</span><br><span class="line">public class SubscriptionSubject implements Subject &#123;</span><br><span class="line">    List&lt;Observer&gt; observerList = new ArrayList&lt;&gt;();</span><br><span class="line">    @Override</span><br><span class="line">    public void attach(Observer observer) &#123;</span><br><span class="line">        observerList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void detach(Observer observer) &#123;</span><br><span class="line">        observerList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void notify(String message) &#123;</span><br><span class="line">        observerList.forEach(o-&gt;&#123;</span><br><span class="line">            o.update(message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line"> System.out.println(&quot;观察者模式========================&quot;);</span><br><span class="line">Subject subject=new SubscriptionSubject();</span><br><span class="line">subject.attach(new WeChatUser(&quot;张三&quot;));</span><br><span class="line">subject.attach(new WeChatUser(&quot;李四&quot;));</span><br><span class="line">subject.notify(&quot;各位亲爱的用户,系统将于今天升级，请知悉！&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/designMode/1649658969%281%29.jpg"><br>优点：  </p>
<ul>
<li>主题对象与订阅者之间是抽象耦合，降低了耦合性</li>
<li>可以事项类似与广播的机制  </li>
</ul>
<p>缺点:   </p>
<ul>
<li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时    </li>
<li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃    </li>
</ul>
<p>使用场景:   </p>
<ul>
<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象    </li>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。  </li>
</ul>
<p><strong>源码分析</strong><br>JDK中提供了java.util.Observable类和java.util.Observer类，只要定义成他们的子类就可以实现观察者模式.<br><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/designMode/1649661294%281%29.jpg"><br><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/designMode/1649666231%281%29.jpg"><br>可以看到，Observable作为具体主题类，Observer作为观察者，Observable中定义了Observer集合,同时定义了添加，删除，通知等方法，当Observable中有更新时，调用notifyObservers方法，去执行Observer中的update，然后将changed变量置为false.<br>我们在使用时，只需要将我们业务中的主题类继承Observable，观察者类实现Observer，在主题类中的通知方法中，将changed变量置为true,然后调用Observable中的notifyObservers方法即可.  </p>
<h2 id="4-7-中介者模式"><a href="#4-7-中介者模式" class="headerlink" title="4.7 中介者模式"></a><strong>4.7 中介者模式</strong></h2>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">一蓑烟雨</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://zhangxiaozesi.github.io/2022/03/07/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%BC%E5%87%BAmysql%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C/">https://zhangxiaozesi.github.io/2022/03/07/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%BC%E5%87%BAmysql%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">一蓑烟雨</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/web/">
                                    <span class="chip bg-color">web</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/03/07/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="JAVA设计模式">
                        
                        <span class="card-title">JAVA设计模式</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-03-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            一蓑烟雨
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/web/">
                        <span class="chip bg-color">web</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/02/28/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="如何快速的搭建个人博客">
                        
                        <span class="card-title">如何快速的搭建个人博客</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-02-28
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            一蓑烟雨
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/web/">
                        <span class="chip bg-color">web</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">一蓑烟雨</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
