<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA设计模式</title>
      <link href="/2022/03/07/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/07/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA设计模式"><a href="#JAVA设计模式" class="headerlink" title="JAVA设计模式"></a><strong>JAVA设计模式</strong></h1><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a><strong>1.单例模式</strong></h2><p>$\color{red}{定义}$：只涉及到一个单一的类，该类创建自己的对象，同时只会创建一个对象被使用<br>$\color{red}{特点}$：构造私有化，自己创建自己的对象并且只会创建一个对象，提供一个返回自身对象的接口供外使用<br>使用场景：<br>1.需要生成唯一序列的环境<br>2.需要频繁实例化然后销毁的对象。<br>3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。<br>4.方便资源相互通信的环境<br>举个例子吧: 我们的电脑中使用的任务管理器，就是一个单例模式。 我们不管点多少次运行任务管理器，是不是操作的都是一个任务管理器的窗口。</p><p>单例模式又分为饿汉模式和懒汉模式两种类型    </p><ul><li>饿汉模式<br>特点：类加载时对象就已经被创建  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;;</span><br><span class="line">    private static Singleton singleton=new Singleton();</span><br><span class="line">    public static Singleton getSingleton()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">静态代码块创建方式：    </span><br><span class="line">public class Singleton1 &#123;</span><br><span class="line">    private Singleton1()&#123;&#125;;</span><br><span class="line">    private static Singleton1 singleton;</span><br><span class="line">    static &#123;</span><br><span class="line">        singleton=new Singleton1();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton1 getSingleton()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>懒汉模式<br>特点: 在使用时才会创建对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">方式一： 锁住获取对象的方法 (锁的粒度大)</span><br><span class="line">public class Singleton2 &#123;</span><br><span class="line">    private Singleton2()&#123;&#125;;</span><br><span class="line">    private static Singleton2 singleton;</span><br><span class="line">    public static synchronized Singleton2 getSingleton()&#123;</span><br><span class="line">        if(singleton==null)&#123;</span><br><span class="line">            singleton = new Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">方式二： 双重检查锁  (锁的粒度小，效率更高)</span><br><span class="line">public class Singleton3 &#123;</span><br><span class="line">    private Singleton3()&#123;&#125;;</span><br><span class="line">    private static Singleton3 singleton;</span><br><span class="line">    public static synchronized Singleton3 getSingleton()&#123;</span><br><span class="line">        //如果不为空不需要占锁</span><br><span class="line">        if(singleton==null)&#123;</span><br><span class="line">            synchronized (Singleton3.class)&#123;</span><br><span class="line">                if(singleton==null)&#123;</span><br><span class="line">                    singleton = new Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">方式三： 静态内部类创建</span><br><span class="line">public class Singleton4 &#123;</span><br><span class="line">    private Singleton4()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private static final Singleton4 singleton4=new Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton4 getSingleton()&#123;</span><br><span class="line">        return SingletonHolder.singleton4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">其它还有什么枚举的创建方式等就不一一说了....</span><br></pre></td></tr></table></figure></li></ul><p>看完单例模式的几种形式后，我们心里有没有疑问？  单例模式是不是坚不可摧的呢，我们有没有可能会破坏单例模式？  好了，那下面就说下单例模式的几种破坏方式。我们就以上例中的静态内部类创建方式为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">破坏方式一:  序列化破坏</span><br><span class="line">public class Singleton5 implements Serializable &#123;</span><br><span class="line">    private Singleton5()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    private static class  Singleton5Holder&#123;</span><br><span class="line">        private static final Singleton5 s=new Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton5 getSingleton()&#123;</span><br><span class="line">        return Singleton5Holder.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    在测试类中测试</span><br><span class="line">    //----将对象输出到文件中</span><br><span class="line">    Singleton5 singleton = Singleton5.getSingleton();</span><br><span class="line">    ObjectOutputStream outputStream=new ObjectOutputStream(new FileOutputStream(&quot;C:\\designMode\\a.txt&quot;));</span><br><span class="line">    outputStream.writeObject(singleton);</span><br><span class="line">    outputStream.close();</span><br><span class="line">    //  读取文件转为对象</span><br><span class="line">    ObjectInputStream objectInputStream=new ObjectInputStream(new FileInputStream(&quot;C:\\designMode\\a.txt&quot;));</span><br><span class="line">    Singleton5 singleton8 = (Singleton5) objectInputStream.readObject();</span><br><span class="line">    ObjectInputStream objectInputStream1=new ObjectInputStream(new FileInputStream(&quot;C:\\designMode\\a.txt&quot;));</span><br><span class="line">    Singleton5 singleton9 = (Singleton5) objectInputStream1.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    objectInputStream1.close();</span><br><span class="line">    System.out.println(&quot;singleton8:&quot;+singleton8);</span><br><span class="line">    System.out.println(&quot;singleton9:&quot;+singleton9);</span><br><span class="line"></span><br><span class="line">破坏方式二：反射破坏单例模式    </span><br><span class="line">    Class&lt;Singleton5&gt; singleton5Class = Singleton5.class;</span><br><span class="line">    //获取无参构造对象</span><br><span class="line">    Constructor declaredConstructors = singleton5Class.getDeclaredConstructor();</span><br><span class="line">    //取消访问检查</span><br><span class="line">    declaredConstructors.setAccessible(true);</span><br><span class="line">    //创建对象</span><br><span class="line">    Singleton5 singleton10 = (Singleton5) declaredConstructors.newInstance();</span><br><span class="line">    Singleton5 singleton11 = (Singleton5) declaredConstructors.newInstance();</span><br><span class="line">    System.out.println(singleton10);</span><br><span class="line">    System.out.println(singleton11);</span><br><span class="line"></span><br><span class="line">    Class&lt;Singleton6&gt; singleton6Class = Singleton6.class;</span><br><span class="line">    //获取无参构造对象</span><br><span class="line">    Constructor declaredConstructors1 = singleton6Class.getDeclaredConstructor();</span><br><span class="line">    //取消访问检查</span><br><span class="line">    declaredConstructors1.setAccessible(true);</span><br><span class="line">    //创建对象</span><br><span class="line">    Singleton6 singleton12 = (Singleton6) declaredConstructors1.newInstance();</span><br><span class="line">    System.out.println(&quot;singleton12:&quot;+singleton12);</span><br><span class="line">    Singleton6 singleton13 = (Singleton6) declaredConstructors1.newInstance();</span><br><span class="line">    System.out.println(&quot;singleton13:&quot;+singleton13);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>来看看输出结果吧<br>  反序列化破坏<br>  <img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/1646642430%281%29.jpg"> </p><p>  反射破坏<br>  <img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/1646643125%281%29.jpg"> </p><p>  可以看到两次的实例均不是一个实例，说明都已破坏了单例模式。 那么，我们该怎么解决这种问题呢？<br>  首先，先分析一下反序列化为什么会出现这种结果。<br>  Singleton5 singleton9 = (Singleton5) objectInputStream1.readObject(); 看看readObject()方法的源码。进入后可以看到有这样一段代码(怎么进的不用我多说了吧，自己debug)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : null;</span><br><span class="line">&#125; catch (Exception ex) &#123;</span><br><span class="line">    throw (IOException) new InvalidClassException(</span><br><span class="line">        desc.forClass().getName(),</span><br><span class="line">        &quot;unable to create instance&quot;).initCause(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，每次反序列化的时候，都会创建一个实例，这就解释了为什么反序列化实例不是一个了。 那么怎么解决怎么问题呢，继续往下看源码。会发现这样一段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if (obj != null &amp;&amp;</span><br><span class="line">          handles.lookupException(passHandle) == null &amp;&amp;</span><br><span class="line">          desc.hasReadResolveMethod())</span><br><span class="line">      &#123;</span><br><span class="line">          Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">          if (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">              rep = cloneArray(rep);</span><br><span class="line">          &#125;</span><br><span class="line">          if (rep != obj) &#123;</span><br><span class="line">              // Filter the replacement object</span><br><span class="line">              if (rep != null) &#123;</span><br><span class="line">                  if (rep.getClass().isArray()) &#123;</span><br><span class="line">                      filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      filterCheck(rep.getClass(), -1);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              handles.setObject(passHandle, obj = rep);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>  关键的地方就在hasReadResolveMethod()关键的地方就在hasReadResolveMethod是true, 就会把invokeReadResolve(obj)生成的对象赋值到obj中. 那么此时我们在单例的类中重写ReadResolve方法，使它返回一个实例就行了，反序列换的时候，就会使用这个实例了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">修改后， 不信的话自己去测试哈！！！</span><br><span class="line">  public class Singleton5 implements Serializable &#123;</span><br><span class="line">      private Singleton5()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">      private static class  Singleton5Holder&#123;</span><br><span class="line">          private static final Singleton5 s=new Singleton5();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static Singleton5 getSingleton()&#123;</span><br><span class="line">          return Singleton5Holder.s;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //反序列化破坏单例模式解决方法: 重写readResolve方法</span><br><span class="line">      public Object readResolve()&#123;</span><br><span class="line">          return Singleton5.getSingleton();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  至于反射会破坏单例模式是因为，反射是通过构造方法创建实例，每次都会创建一个心的实例，所以每次的实例都不一样。 那么怎么解决呢？ 看代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  public class Singleton6 implements Serializable &#123;</span><br><span class="line">    private static boolean flag=false;</span><br><span class="line">    private Singleton6()&#123;</span><br><span class="line">        //反射获取对象破坏单例模式解决方法:   构造里面判断对象是否重复</span><br><span class="line">        synchronized (Singleton6.class)&#123;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                throw new RuntimeException(&quot;不能创建多个对象&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            flag=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private static class  Singleton5Holder&#123;</span><br><span class="line">        private static final Singleton6 s=new Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton6 getSingleton()&#123;</span><br><span class="line">        return Singleton5Holder.s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">在构造方法里面判断对象是否多次创建，是的话就抛异常</span><br></pre></td></tr></table></figure><h2 id="2-创建者模式"><a href="#2-创建者模式" class="headerlink" title="2.创建者模式"></a><strong>2.创建者模式</strong></h2><p>假设现在有个需求场景：现在有两种咖啡，摩卡咖啡和拿铁咖啡, 还有一家咖啡店，可以订购两种咖啡, 就这种场景，我们会想到怎么设计呢? 我们先来看看最简陋的设计, 设计一个咖啡的抽象类， 拿铁咖啡类和美式咖啡类实现咖啡接口，然后设计一个咖啡店类，写一个获取咖啡的接口。 具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//咖啡类</span><br><span class="line">public abstract class Coffee &#123;                                 </span><br><span class="line">    public abstract void getName();</span><br><span class="line">    public void addMilk()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加奶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addSweet()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加糖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//拿铁咖啡</span><br><span class="line">public class LatteCoffee extends Coffee &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;拿铁咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//摩卡咖啡</span><br><span class="line">public class MochaCoffee extends Coffee &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;摩卡咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//咖啡店</span><br><span class="line">public class CoffeeStore &#123;</span><br><span class="line">    private Coffee coffee;</span><br><span class="line">    //订购咖啡</span><br><span class="line">    public void orderCoffee(String type)&#123;</span><br><span class="line">        if(&quot;latte&quot;.equals(type))&#123;</span><br><span class="line">            coffee=new LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        if(&quot;mocha&quot;.equals(type))&#123;</span><br><span class="line">            coffee=new MochaCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        coffee.getName();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSweet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次通过传入不同的type就可以订到不同的咖啡。但是这样做的话，会有以下问题：</p><ol><li>咖啡店于咖啡的耦合度过高， 试想一下，假设我现在不止一家咖啡店，还有甜品点，饮品点。。。。，一共有10家点，都可以购买咖啡，现在市面上新出了一款咖啡， 那我还需要在每家店的类里面都修改CoffeeStore这个方法吗？  what? 这不是增加重复的工作量吗？ 基于这一点，我们对以上代码进行了一步优化， 简单工厂模式应运而生。来看看简单工厂模式代码吧！<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">简单工厂模式</span><br><span class="line">//咖啡类</span><br><span class="line">public abstract class Coffee1 &#123;</span><br><span class="line">    public abstract void getName();</span><br><span class="line">    public void addMilk()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加奶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addSweet()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加糖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//拿铁咖啡</span><br><span class="line">public class LatteCoffee1 extends Coffee1 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;拿铁咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//摩卡咖啡</span><br><span class="line">public class MochaCoffee1 extends Coffee1 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;摩卡咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//咖啡店</span><br><span class="line">public class CoffeeStore1 &#123;</span><br><span class="line">    public void orderCoffee(String type)&#123;</span><br><span class="line">        Coffee coffee = CoffeeFactory.createCoffee(type);</span><br><span class="line">        coffee.getName();</span><br><span class="line">        coffee.addSweet();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//咖啡工厂</span><br><span class="line">public class CoffeeFactory &#123;</span><br><span class="line">    //生产咖啡</span><br><span class="line">    public static Coffee createCoffee(String type)&#123;</span><br><span class="line">        Coffee coffee=null;</span><br><span class="line">        if(&quot;latte&quot;.equals(type))&#123;</span><br><span class="line">            coffee=new LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        if(&quot;mocha&quot;.equals(type))&#123;</span><br><span class="line">            coffee=new MochaCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        return coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到，咖啡店与咖啡之间没有了直接的依赖关系， 生产咖啡的任务交给了工厂类， 那么以后不管多少家店，多少款咖啡，都只需要修改工厂类里面的代码了。 这样做是不是不用再重复的在多家店里面修改代码了！！！  但是简单工厂模式虽然比最初的设计方案优化， 仍存在不少的问题，比如：<br>工厂与咖啡的耦合度还是很高， 新出了咖啡的话，工厂里面还是得修改代码，这显然不符合开闭原则啊。 那么我们思考下，怎么设计符合开闭原则呢？ 来看看另外一种模式–工厂方法模式，先看代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//咖啡类</span><br><span class="line">public abstract class Coffee2 &#123;</span><br><span class="line">    public abstract void getName();</span><br><span class="line">    public void addMilk()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加奶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addSweet()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加糖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CoffeeStore2 &#123;</span><br><span class="line">    private CoffeeFactory2 coffeeFactory2;</span><br><span class="line">    public void setCoffeeFactory2(CoffeeFactory2 coffeeFactory2)&#123;</span><br><span class="line">        this.coffeeFactory2=coffeeFactory2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void orderCoffee()&#123;</span><br><span class="line">        Coffee2 coffee = coffeeFactory2.createCoffee();</span><br><span class="line">        coffee.getName();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSweet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class LatteCoffee2 extends Coffee2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;拿铁咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public interface CoffeeFactory2 &#123;</span><br><span class="line">    public abstract Coffee2 createCoffee();</span><br><span class="line">&#125;</span><br><span class="line">public class LatteCoffeeFactory2 implements CoffeeFactory2&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Coffee2 createCoffee() &#123;</span><br><span class="line">        return new LatteCoffee2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MochaCoffeeFactory2 implements CoffeeFactory2&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Coffee2 createCoffee() &#123;</span><br><span class="line">        return new MochaCoffee2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CoffeeStore2 &#123;</span><br><span class="line">    private CoffeeFactory2 coffeeFactory2;</span><br><span class="line">    public void setCoffeeFactory2(CoffeeFactory2 coffeeFactory2)&#123;</span><br><span class="line">        this.coffeeFactory2=coffeeFactory2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void orderCoffee()&#123;</span><br><span class="line">        Coffee2 coffee = coffeeFactory2.createCoffee();</span><br><span class="line">        coffee.getName();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSweet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>不难发现,和简单工厂模式不同的是,工厂方法模式是将工厂定义为接口，每一种咖啡都有一个具体的咖啡工厂类去实现工厂接口，生产一款咖啡。 这样每次出了新款的咖啡， 只需要新家具体咖啡工厂类就可以了。 对扩展开放，对修改关闭，符合了开闭原则。 但是这样做也有对应的确定，想一下，如果每增加一个产品，我都要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 如果产品多了，容易类爆炸。<br>上面所介绍的工厂方法模式中使用的场景是一类产品的生产，如咖啡厂只生产咖啡；视机厂只生产电视机。 但是如果现实生活中，我们需要一个工厂可以生产不同类型的产品，  如电器厂可以生产电视机和冰箱， 甜品厂可以生产咖啡和甜点，显然用工厂方法模式就不适用，此时可以考虑另外一种设计模式：抽象工厂模式.  要了解抽象工厂模式，首先得清楚两个概念: 产品等级接口，产品族。<br>$\color{red}{产品等级结构：}$同一类产品的继承结构，  如有一个电视机抽象类，  还有海尔电视机和海信电视机两个子类，我们可以把它们称为一个产品等级结构（电视机等级结构）。  一个汽车抽象类， 有宝马汽车子类和奔驰汽车子类， 我们也可以把他们称为一个产品等级（汽车等级结构）<br>$\color{red}{产品族：}$由同一个工厂生产的，不同等级结构的一组产品。  如电器厂生产海尔电视机和海尔冰箱。  海尔电视机属于电视机等级机构， 海尔冰箱数据冰箱等级结构。 海尔电视机和海尔冰箱就构成了一个产品族。     </li></ol><p>所以：当系统中所提供的工厂要生产的产品有多个产品等级时，可以考虑使用抽象工厂模式。  </p><p>抽象工厂模式的主要角色如下：</p><ol><li><p>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</p></li><li><p>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</p></li><li><p>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</p></li><li><p>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。  </p></li></ol><p>接下来，我们还是以咖啡店为例子，假设咖啡店不仅要生产咖啡还要生产甜点，如提拉米苏、阿拉伯糖丸等，要是按照工厂方法<br>模式，需要定义提拉米苏类、阿拉伯糖丸类、提拉米苏工厂、阿拉伯糖丸工厂、甜点工厂类，很容易发生类<br>爆炸情况。其中拿铁咖啡、摩卡咖啡是一个产品等级，都是咖啡；提拉米苏、阿拉伯糖丸也是一个产品等<br>级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），摩卡咖啡和阿拉伯糖丸是同一产品<br>族（也就是都属于阿拉伯风味）。所以这个案例可以使用抽象工厂模式实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">抽象工厂模式</span><br><span class="line">//咖啡类</span><br><span class="line">public abstract class Coffee3 &#123;</span><br><span class="line">    public abstract void getName();</span><br><span class="line">    public void addMilk()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加奶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addSweet()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加糖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//拿铁咖啡</span><br><span class="line">public class LatteCoffee3 extends Coffee3 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;拿铁咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//摩卡咖啡</span><br><span class="line">public class MochaCoffee3 extends Coffee3 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;摩卡咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 甜品工厂  生产咖啡和甜点</span><br><span class="line">public interface DessertFactory &#123;</span><br><span class="line">    public Dessert createDessert();</span><br><span class="line">    public Coffee3 createCoffee();</span><br><span class="line">&#125;</span><br><span class="line">//意大利工厂  生产拿铁咖啡 和  提拉米苏</span><br><span class="line">public class ItalyDessertFactory implements DessertFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Dessert createDessert() &#123;</span><br><span class="line">        return new Trimisu();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Coffee3 createCoffee() &#123;</span><br><span class="line">        return new LatteCoffee3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//阿拉伯工厂  生产摩卡咖啡 和  炸糖丸</span><br><span class="line">public class ArabDessertFactory implements DessertFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Dessert createDessert() &#123;</span><br><span class="line">        return new Luqaimat();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Coffee3 createCoffee() &#123;</span><br><span class="line">        return new MochaCoffee3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/1647078629%281%29.jpg"><br>如果后续要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。  </p><p>优点：<br>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始&amp;终只使用同一个产品族中的对象。<br>缺点：<br>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。      </p><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展:"></a><strong>模式扩展</strong>:</h3><p>除以上几种模式，实际开发中，还有人会用到一种模式,通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全<br>类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">模式扩展</span><br><span class="line">//咖啡类</span><br><span class="line">public abstract class Coffee4 &#123;</span><br><span class="line">    public abstract void getName();</span><br><span class="line">    public void addMilk()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加奶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addSweet()&#123;</span><br><span class="line">        System.out.println(&quot;咖啡加糖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//拿铁咖啡</span><br><span class="line">public class LatteCoffee4 extends Coffee4 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;拿铁咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//摩卡咖啡</span><br><span class="line">public class MochaCoffee4 extends Coffee4 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line">        System.out.println(&quot;摩卡咖啡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CoffeeFactory4 &#123;</span><br><span class="line">    public static Map&lt;String,Coffee4&gt; coffee4Map=new HashMap&lt;&gt;();</span><br><span class="line">    //加载配置类 装进map里面</span><br><span class="line">    static &#123;</span><br><span class="line">        Properties p=new Properties();</span><br><span class="line">        InputStream in=CoffeeFactory4.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            p.load(in);</span><br><span class="line">            Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">            for (Object key:keys) &#123;</span><br><span class="line">                String className = p.getProperty((String) key);</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">                Coffee4 coffee4 = (Coffee4) clazz.newInstance();</span><br><span class="line">                coffee4Map.put((String) key,coffee4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public Coffee4 getCoffee(String name)&#123;</span><br><span class="line">        return coffee4Map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速的搭建个人博客</title>
      <link href="/2022/02/28/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/02/28/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="如何使用hexo快速搭建个人博客"><a href="#如何使用hexo快速搭建个人博客" class="headerlink" title="如何使用hexo快速搭建个人博客"></a><strong>如何使用hexo快速搭建个人博客</strong></h1><h2 id="1-node-js，Git环境搭建"><a href="#1-node-js，Git环境搭建" class="headerlink" title="1.node.js，Git环境搭建"></a>1.node.js，Git环境搭建</h2><ol><li><a href="https://blog.csdn.net/qq_43285335/article/details/90696126">nodejs搭建教程</a></li><li><a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">git搭建教程</a></li></ol><h2 id="2-创建github仓库"><a href="#2-创建github仓库" class="headerlink" title="2.  创建github仓库**"></a>2.  创建github仓库**</h2><ol start="3"><li>注册github账号, 创建github仓库<br>(注意格式:  “用户名”+”.github”+”.io”) <img src="https://img-blog.csdnimg.cn/b410a114a036447a95b285c002c3df3c.png#pic_center" alt="在这里插入图片描述"></li></ol><h2 id="3-利用hexo搭建博客"><a href="#3-利用hexo搭建博客" class="headerlink" title="3. 利用hexo搭建博客"></a>3. 利用hexo搭建博客</h2><p> （点击进入<a href="https://hexoscript.gitbook.io/hexo-script/v/1.3-1/">文档</a>）</p><pre><code>3.1   创建文件夹，我的文件夹路径是C:\BLOG,将install.sh下载到BLOG文件夹下   </code></pre><p> <img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/1646043137%281%29.jpg">  </p><p> 3.2(友情提示: 在做此步骤前,请配置<a href="https://www.cnblogs.com/luyuandatabase/p/12145707.html">淘宝镜像</a>，不然会很慢！很慢！很慢！) 在存放install.sh 的目录中，打开git bash here,<br>  运行 source install.sh hexo_win命令,出现如图显示，表示成功<br>  <img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/5.png">     </p><p>  3.3 做完3.3后，会自动生成hexoblog文件夹,进入到hexoblog文件夹，打开<br>  git bash here,运行hexo s命令，可以看到出现了<a href="http://localhost:4000地址，访问这个地址，就可以本地预览你的博客了！！">http://localhost:4000地址，访问这个地址，就可以本地预览你的博客了！！</a></p><p>  3.4  生产github秘钥<br>       在存放 install.sh脚本的目录中，打开git bash here, 运行./install.sh git_ssh命令, 出现如下截图<br>       <img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/33.png">, 选择 1，然后回车回车…..，最后会生成<br>       <img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/1646045029%281%29.jpg">两个文件，秘钥就在id_rsa.pub文件中      </p><p>  3.5 在存放install.sh脚本的目录下，打开git bash here,运行 source install.sh deploy命令,会出现up.sh脚本文件,  将文件复制到 hexoblog文件夹中，然后编辑 hexoblog目录下的_config.yml文件，<br>  <img src="https://guli-zs.oss-cn-heyuan.aliyuncs.com/1646097488%281%29.jpg">),填上自己github的仓库地址(注意：是ssh地址哦！)和分支，保存退出后，打开git bash here后,  运行 source up.sh，编码就会自动部署到github上，如果访问github个人博客,  可运行hexo  clean,   再运行 hexo  d，https://“github账户名”.github.io/便可访问.</p><p>3.6   个人博客主题切换<br><a href="https://blog.csdn.net/jspnetcn/article/details/104111651">主题安装参照教程</a>    </p><p>ok!  个人博客已经安装完毕，本人的第一篇博客，欢迎各位大神指教，哈哈！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
